/* prefixExp.c, Gerard Renardel, 29 January 2014
 *
 * In this file functions are defined for the construction of expression trees
 * from prefix expressions generated by the following BNF grammar:
 *
 * <infixexp>     ::=   <number> |  <identifier> | '+' <infixexp>
 *                      | '-' <infixexp> | '*' <infixexp> | '/' <infixexp>
 *
 * <number>       ::=   <digit> { <digit> }
 *
 * <identifier>   ::=   <letter> { <letter> | <digit> }
 *
 * Starting point is the token list obtained from the scanner (in scanner.c).
 */

#include <stdio.h>  /* printf */
#include <stdlib.h> /* malloc, free */
#include <assert.h> /* assert */
#include "scanner.h"
#include "recognizeExp.h"
#include "evalExp.h"
#include "infixExp.h"

/* The function newExpTreeNode creates a new node for an expression tree.
 */
ExpTree newExpTreeNode(TokenType tt, Token t, ExpTree tL, ExpTree tR) {
  ExpTree new = malloc(sizeof(ExpTreeNode));
  assert (new != NULL);
  new->tt = tt;
  new->t = t;
  new->left = tL;
  new->right = tR;
  return new;
}

/* The function valueIdentifier recognizes an identifier in a token list and
 * makes the second parameter point to it.
 */
int valueIdentifier(List *lp, char **sp) {
  if (*lp != NULL && (*lp)->tt == Identifier) {
    *sp = ((*lp)->t).identifier;
    *lp = (*lp)->next;
    return 1;
  }
  return 0;
}

/* The function valueOperator recognizes an arithmetic operator in a token list
 * and makes the second parameter point to it.
 * Here the auxiliary function isOperator is used.
 */
int isOperator(char c) {
  return (c == '+' || c == '-' || c == '*' || c == '/');
}

/* We modified valueOperator so that it checks for a specific operator instead of the isOperator above
 */
int valueOperator(List *lp, char *cp, char op) {
  if (*lp != NULL && (*lp)->tt == Symbol && ((*lp)->t).symbol == op) {
    *cp = ((*lp)->t).symbol;
    *lp = (*lp)->next;
    return 1;
  }
  return 0;
}

/* De functie freeExpTree frees the memory of the nodes in the expression tree.
 * Observe that here, unlike in freeList, the strings in indentifier nodes
 * are not freed. The reason is that the function newExpTree does not allocate
 * memory for strings in nodes, but only a pointer to a string in a node
 * in the token list.
 */
void freeExpTree(ExpTree tr) {
  if (tr == NULL) {
    return;
  }
  freeExpTree(tr->left);
  freeExpTree(tr->right);
  free(tr);
}

/* The function treeExpression tries to build a tree from the tokens in the token list 
 * (its first argument) and makes its second argument point to the tree.
 * The return value indicates whether the action is successful.
 * Observe that we use mutual recursion.
 */
int treeInfixExpression(List *lp, ExpTree *tp);


/* acceptTreeFactor
 * treeFactor:  number || identifier || '(' <infexp> ')'
 */
int acceptTreeFactor(List *lp, ExpTree *tp) {
  double w;
  char *s;
  Token t;

  if (valueNumber(lp, &w)) {
    t.number = (int) w;
    *tp = newExpTreeNode(Number, t, NULL, NULL);
    return 1;
  } else if (valueIdentifier(lp, &s)) {
    t.identifier = s;
    *tp = newExpTreeNode(Identifier, t, NULL, NULL);
    return 1;
  } else if (acceptCharacter(lp, '(')
             && treeInfixExpression(lp, tp)
             && acceptCharacter(lp, ')')) {
    return 1;
  } else {
    return 0;
  }
}

/* acceptTreeTerm
 * treeTerm: factor || factor*factor || factor/factor
 */
int acceptTreeTerm(List *lp, ExpTree *tp) {
  char c;
  Token t;
  ExpTree tR;
  if (acceptTreeFactor(lp, tp)) {
    while (valueOperator(lp, &c, '*') || valueOperator(lp, &c, '/')) {
      if (acceptTreeFactor(lp, &tR)) {
        t.symbol = c;
        // tp to left, tR to right
        *tp = newExpTreeNode(Symbol, t, *tp, tR);
      } else {
        free(tR);
        return 0;
      }
    }
    return 1;
  }
  return 0;
}

/* treeInfixExpression
 * treeInfixExpression: term || term+term || term-term
 */
int treeInfixExpression(List *lp, ExpTree *tp) {
  char c;
  Token t;
  ExpTree tR;
  if (acceptTreeTerm(lp, tp)) {
    while (valueOperator(lp, &c, '+') || valueOperator(lp, &c, '-')) {
      if (acceptTreeTerm(lp, &tR)) {
        t.symbol = c;
        // tp to left, tR to right
        *tp = newExpTreeNode(Symbol, t, *tp, tR);
      } else {
        free(tR);
        return 0;
      }
    }
    /* no + or -, so we reached the end of the expression */
    return 1;
  }
  return 0;
}

/* The function printExpTreeInfix does what its name suggests.
 */
void printExpTreeInfix(ExpTree tr) {
  if (tr == NULL) {
    return;
  }
  switch (tr->tt) {
    case Number:
      printf("%d", (tr->t).number);
      break;
    case Identifier:
      printf("%s", (tr->t).identifier);
      break;
    case Symbol:
      printf("(");
      printExpTreeInfix(tr->left);
      printf(" %c ", (tr->t).symbol);
      printExpTreeInfix(tr->right);
      printf(")");
      break;
  }
}

/* The function isNumerical checks for an expression tree whether it represents 
 * a numerical expression, i.e. without identifiers.
 */
int isNumerical(ExpTree tr) {
  assert(tr != NULL);
  if (tr->tt == Number) {
    return 1;
  }
  if (tr->tt == Identifier) {
    return 0;
  }
  return (isNumerical(tr->left) && isNumerical(tr->right));
}

/* The function valueExpTree computes the value of an expression tree that represents a
 * numerical expression.
 */

double valueExpTree(ExpTree tr) {  /* precondition: isNumerical(tr)) */
  double lval, rval;
  assert(tr != NULL);
  if (tr->tt == Number) {
    return (tr->t).number;
  }
  lval = valueExpTree(tr->left);
  rval = valueExpTree(tr->right);
  switch ((tr->t).symbol) {
    case '+':
      return (lval + rval);
    case '-':
      return (lval - rval);
    case '*':
      return (lval * rval);
    case '/':
      assert(rval != 0);
      return (lval / rval);
    default:
      abort();
  }
}

/* the function prefExpressionExpTrees performs a dialogue with the user and tries
 * to recognize the input as a prefix expression. When it is a numerical prefix 
 * expression, its value is computed and printed.
 */
void infExpTrees() {
  char *ar;
  List tl, tl1;
  ExpTree t = NULL;
  printf("give an expression: ");
  ar = readInput();
  while (ar[0] != '!') {
    tl = tokenList(ar);
//    printf("the token list is "); //<- should not be printed in final
    printList(tl);
    tl1 = tl;
    //    infix part:
    if (treeInfixExpression(&tl1, &t) && tl1 == NULL) {
      /* there should be no tokens left */
      printf("in infix notation: ");
      printExpTreeInfix(t);
      printf("\n");
      if (isNumerical(t)) {
        printf("the value is %g\n", valueExpTree(t));
      } else {
        printf("this is not a numerical expression\n");
      }
    } else {
      printf("this is not an expression\n");
    }

    freeExpTree(t);
    t = NULL;
    freeTokenList(tl);
    free(ar);
    printf("\ngive an expression: ");
    ar = readInput();
  }
  free(ar);
  printf("good bye\n");
}

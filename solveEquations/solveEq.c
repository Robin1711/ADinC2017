/* recognizeExp.c, Gerard Renardel, 29 January 2014
 *
 * In this file a recognizer acceptExpression is definined that can recognize 
 * arithmetical expressions generated by the following BNF grammar:
 *
 * <expression>  ::= <term> { '+'  <term> | '-' <term> }
 * 
 * <term>       ::= <factor> { '*' <factor> | '/' <factor> }
 *
 * <factor>     ::= <number> | <identifier> | '(' <expression> ')'
 *
 * Input for the recognizer is the token list constructed by the scanner (in scanner.c). 
 * For the recognition of a token list the method of *recursive descent* is used. 
 * It relies on the use of three functions for the recognition and processing of
 * terms, factors and expressions, respectively. 
 * These three functions are defined with mutual recursion, corresponding with the 
 * structure of the BNF grammar.
 */

/* The grammar implemented after the modification
 * <equation>   ::= <expression> '=' <expression>
 *
 * <expression> ::= <term> { '+'  <term> | '-' <term> }
 *                | '-' <term> { '+'  <term> | '-' <term> }
 *
 * <term>       ::= <natnum> | <natnum> <identifier> | <natnum> <identifier> '^' <natnum>
*/

#include <stdio.h>  /* getchar, printf */
#include <stdlib.h> /* NULL */
#include <math.h> /* sqrt */
#include "scanner.h"
#include "solveEq.h"
#include <assert.h>

const int TRUE = 1;
const int FALSE = 0;

/* The functions acceptNumber, acceptIdentifier and acceptCharacter have as
 * (first) argument a pointer to an token list; moreover acceptCharacter has as
 * second argument a character. They check whether the first token
 * in the list is a number, an identifier or the given character, respectively.
 * When that is the case, they yield the value 1 and the pointer points to the rest of
 * the token list. Otherwise they yield 0 and the pointer remains unchanged.
 */

int valueNumber(List *lp, double *wp) {
  if (*lp != NULL && (*lp)->tt == Number) {
    *wp = ((*lp)->t).number;
    *lp = (*lp)->next;
    return 1;
  }
  return 0;
}

int acceptNumber(List *lp) {
  if (*lp != NULL && (*lp)->tt == Number) {
    *lp = (*lp)->next;
    return 1;
  }
  return 0;
}

int acceptIdentifier(List *lp) {
  if (*lp != NULL && (*lp)->tt == Identifier) {
    *lp = (*lp)->next;
    return 1;
  }
  return 0;
}

int acceptCharacter(List *lp, char c) {
  if (*lp != NULL && (*lp)->tt == Symbol && ((*lp)->t).symbol == c) {
    *lp = (*lp)->next;
    return 1;
  }
  return 0;
}

/* The functions acceptEquation, acceptTerm and acceptExpression have as
 * argument a pointer to a token list. They check whether the token list
 * has an initial segment that can be recognized as equation, term or expression, respectively.
 * When that is the case, they yield the value 1 and the pointer points to the rest of
 * the token list. Otherwise they yield 0 and the pointer remains unchanged.
 */

int acceptTerm(List *lp) {
  if (!acceptNumber(lp)) {
    return FALSE;
  }
  if (acceptIdentifier(lp)) {
    if (acceptCharacter(lp, '^')) {
      if (acceptNumber(lp)) {
        return TRUE;
      }
      return FALSE;
    }
    return TRUE;
  }
  return TRUE;
}

int acceptExpression(List *lp) {
  if (!(acceptTerm(lp) || (acceptCharacter(lp, '-') && acceptTerm(lp)))) {
    return FALSE;
  }
  while (acceptCharacter(lp, '+') || acceptCharacter(lp, '-')) {
    if (!acceptTerm(lp)) {
      return FALSE;
    }
  } /* no + or -, so we reached the end of the expression */
  return TRUE;
}

int acceptEquation(List *lp) {
  if (!acceptExpression(lp)) {
    return FALSE;
  }
  if (!acceptCharacter(lp, '=')) {
    return FALSE;
  }
  if (!acceptExpression(lp)) {
    return FALSE;
  }
  return TRUE;
}

/* The function isEqual checks whether two arrays are equal */
int isEqual(char *ar1, char *ar2, int size) {
  int i;
  for (i = 0; i < size; i++) {
    if (ar1[i] == '\0' && ar2[i] == '\0') {
      return TRUE;
    }
    if (ar1[i] != ar2[i]) {
      return FALSE;
    }
  }
  return TRUE;
}

/* The function isOneVar checks whether the equation (given in list-form) contains one distinct variable or not */
int isOneVar(List *lp) {
  int varFound = FALSE;
  char *var;
  while (*lp != NULL) {
    if ((*lp)->tt == Identifier) {
      if (!varFound) {
        varFound = TRUE;
        var = (*lp)->t.identifier;
      } else {
        if (!isEqual(var, (*lp)->t.identifier, MAXIDENT * 10)) {
          return FALSE;
        }
      }
    }
    *lp = (*lp)->next;
  }
  return varFound;
}

int max(int a, int b) {
  return (a > b) ? a : b;
}

/* The function returns the degree of the equation (given in list-form) */
int degree(List *lp) {
  int degree = 0;
  while (*lp != NULL) {
    if (acceptIdentifier(lp)) {
      if (*lp != NULL && acceptCharacter(lp, '^')) {
        degree = max(degree, (*lp)->t.number);
      } else {
        degree = max(degree, 1);
      }
    }
    if (*lp != NULL) {
      *lp = (*lp)->next;
    }
  }
  return degree;
}

/* The function checkDeg checks the degree of a term in the equation (given in list-form) */
int checkDeg(List *lp) {
  double val;
  if (acceptIdentifier(lp)) {
    if (acceptCharacter(lp, '^')) {
      valueNumber(lp, &val);
      return val;
    }
    else {
      return 1;
    }
  }
  return 0;
}

double round(double n) {
  if (n < 0.0005 && n >= -0.0005) {
    return 0;
  }
  else {
    return n;
  }
}

/* The function getABC gets as input an equation in list-form and an array with length 3
 * The function returns a filled array with the values for a, b and c as in (ax^2 + bx + c) */
void getABC(List *lp, double *vars) {
  double val;
  int deg, foundEquals, minus;
  minus = 1;
  foundEquals = FALSE;
  while (*lp != NULL) {
    if (acceptCharacter(lp, '-')) {
      minus = -1;
    }
    if (valueNumber(lp, &val)) {
      deg = checkDeg(lp);
      vars[deg] = (foundEquals ? vars[deg] - val * minus : vars[deg] + val * minus);
    } else if (acceptCharacter(lp, '=')) {
      foundEquals = TRUE;
    } else if (*lp != NULL) {
      *lp = (*lp)->next;
    }
    minus = 1;
  }
}

/* The function abcFormula calculates the Discriminant and then performs the abc-formula
 * when d > 0 and it is a second degree equation. Otherwise it will calculate the linear solution
 * The function prints the result(s) */
void abcFormula(double a, double b, double c) {
  double d = (b * b) - (4 * a * c);
  if (d > 0 && a != 0) {
    double sol1 = (-1 * b - sqrt(d)) / (2 * a);
    double sol2 = (-1 * b + sqrt(d)) / (2 * a);
    sol1 = round(sol1);
    sol2 = round(sol2);
    printf("solutions: ");
    (sol1 < sol2) ? printf("%.3lf %.3lf\n", sol2, sol1) : printf("%.3lf %.3lf\n", sol1, sol2);
  } else if (d == 0 && a != 0) {    //<< if d=0 only one solution
    printf("solution: %.3lf\n", (-1 * b) / (2 * a));
  } else if (a == 0) {              //<< if the equation is linear
    printf("solution: %.3lf\n", round(-1 * c / b));
  } else {
    printf("not solvable\n");
  }
}

/* The function solveEq will get an equation and it will calculate the result(s) of the equation */
void solveEq(List *lp) {
  double *vars;
  vars = calloc(3, sizeof(double));//<<CONSTANT
  getABC(lp, vars);
  if (vars[2] == 0 && vars[1] == 0) { //<< if constant = 0
    printf("not solvable\n");
  } else {
    abcFormula(vars[2], vars[1], vars[0]);
  }
  free(vars);
}

void solveEquations() {
  char *ar;
  List tl, tl1;
  printf("give an equation: ");
  ar = readInput();
  while (ar[0] != '!') {
    tl = tokenList(ar);
    printList(tl);
    tl1 = tl;
    if (acceptEquation(&tl1) && tl1 == NULL) {
      tl1 = tl;
      printf("this is an equation");
      if (isOneVar(&tl1)) {
        tl1 = tl;
        int deg = degree(&tl1);
        tl1 = tl;
        printf(" in 1 variable of degree %d\n", deg);
        if (deg == 1 || deg == 2) {
          solveEq(&tl1);
        }
      } else {
        printf(", but not in 1 variable\n");
      }
    } else {
      printf("this is not an equation\n");
    }
    free(ar);
    freeTokenList(tl);
    printf("\ngive an equation: ");
    ar = readInput();
  }
  free(ar);
  printf("good bye\n");
}
